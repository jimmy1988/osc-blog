{"version":3,"sources":["../../../../src/morphology/german/generateNounExceptionForms.js"],"names":["generateNounExceptionForms","checkStemsFromExceptionList","exceptionStems","stemmedWordToCheck","i","length","currentStemDataSet","stemPairToCheck","j","exceptionStemMatched","endsWith","precedingLength","precedingLexicalMaterial","slice","stemsToReturn","map","concat","currentStem","checkStemsWithPredictableSuffixes","exceptionCategory","exceptionsToTheException","some","ending","suffixes","suffix","morphologyDataNouns","exceptions","exceptionStemsWithFullForms","exceptionsStemsPredictableSuffixes","Object","keys","key","push"],"mappings":"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","file":"generateNounExceptionForms.js","sourcesContent":["/**\n * Checks whether a stemmed word is on the exception list for which we have full forms.\n *\n * @param {Array} exceptionStems        The exception stems to check against.\n * @param {string} stemmedWordToCheck   The stem to check.\n *\n * @returns {string[]} The created word forms.\n */\nconst checkStemsFromExceptionList = function( exceptionStems, stemmedWordToCheck ) {\n\tfor ( let i = 0; i < exceptionStems.length; i++ ) {\n\t\tconst currentStemDataSet = exceptionStems[ i ];\n\n\t\tconst stemPairToCheck = currentStemDataSet[ 0 ];\n\n\t\tfor ( let j = 0; j < stemPairToCheck.length; j++ ) {\n\t\t\tconst exceptionStemMatched = stemmedWordToCheck.endsWith( stemPairToCheck[ j ] );\n\n\t\t\t// Check if the stemmed word ends in one of the stems of the exception list.\n\t\t\tif ( exceptionStemMatched === true ) {\n\t\t\t\t// \"Haupt\".length = \"Hauptstadt\".length - \"stadt\".length\n\t\t\t\tconst precedingLength = stemmedWordToCheck.length - stemPairToCheck[ j ].length;\n\t\t\t\tconst precedingLexicalMaterial = stemmedWordToCheck.slice( 0, precedingLength );\n\t\t\t\t/*\n\t\t\t \t * If the word is a compound, removing the final stem will result in some lexical material to\n\t\t\t \t * be left over at the beginning of the word. For example, removing \"stadt\" from \"Hauptstadt\"\n\t\t\t \t * leaves \"Haupt\". This lexical material is the base for the word forms that need to be created\n\t\t\t \t * (e.g., \"HauptstÃ¤dte\").\n\t\t\t \t */\n\t\t\t\tif ( precedingLexicalMaterial.length > 0 ) {\n\t\t\t\t\tconst stemsToReturn = currentStemDataSet[ 1 ];\n\t\t\t\t\treturn stemsToReturn.map( currentStem => precedingLexicalMaterial.concat( currentStem ) );\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Return all possible stems since apparently the word that's being checked is equal to the stem on the\n\t\t\t\t * exception list that's being checked.\n\t\t\t\t */\n\t\t\t\treturn currentStemDataSet[ 1 ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Checks whether a stemmed word has an ending for which we can predict possible suffix forms.\n *\n * @param {array} exceptionCategory     The exception category to check.\n * @param {string} stemmedWordToCheck   The stem to check.\n *\n * @returns {string[]} The created word forms.\n */\nconst checkStemsWithPredictableSuffixes = function( exceptionCategory, stemmedWordToCheck ) {\n\t// There are some exceptions to this rule. If the current stem falls into this category, the rule doesn't apply.\n\tconst exceptionsToTheException = exceptionCategory[ 2 ];\n\n\tif ( exceptionsToTheException.some( ending => stemmedWordToCheck.endsWith( ending ) ) ) {\n\t\treturn [];\n\t}\n\n\tconst exceptionStems = exceptionCategory[ 0 ];\n\n\t// Return forms of stemmed word with appended suffixes.\n\tif ( exceptionStems.some( ending => stemmedWordToCheck.endsWith( ending ) ) ) {\n\t\tconst suffixes = exceptionCategory[ 1 ];\n\n\t\treturn suffixes.map( suffix => stemmedWordToCheck.concat( suffix ) );\n\t}\n\n\treturn [];\n};\n\n/**\n * Checks whether a give stem stem falls into any of the noun exception categories and creates the\n * correct forms if that is the case.\n *\n * @param {Object}  morphologyDataNouns The German morphology data for nouns.\n * @param {string}  stemmedWordToCheck  The stem to check.\n *\n * @returns {string[]} The created word forms.\n */\nexport function generateNounExceptionForms( morphologyDataNouns, stemmedWordToCheck ) {\n\t// Check exceptions with full forms.\n\tlet exceptions = checkStemsFromExceptionList( morphologyDataNouns.exceptionStemsWithFullForms, stemmedWordToCheck );\n\n\tif ( exceptions.length > 0 ) {\n\t\treturn exceptions;\n\t}\n\n\t// Check exceptions with predictable suffixes.\n\tconst exceptionsStemsPredictableSuffixes = morphologyDataNouns.exceptionsStemsPredictableSuffixes;\n\n\tfor ( const key of Object.keys( exceptionsStemsPredictableSuffixes ) ) {\n\t\texceptions = checkStemsWithPredictableSuffixes( exceptionsStemsPredictableSuffixes[ key ], stemmedWordToCheck );\n\t\tif ( exceptions.length > 0 ) {\n\t\t\t// For this class of words, the stemmed word is the singular form and therefore needs to be added.\n\t\t\texceptions.push( stemmedWordToCheck );\n\t\t\treturn exceptions;\n\t\t}\n\t}\n\n\treturn exceptions;\n}\n"]}