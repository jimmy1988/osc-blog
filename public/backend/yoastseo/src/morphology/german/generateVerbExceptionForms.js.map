{"version":3,"sources":["../../../../src/morphology/german/generateVerbExceptionForms.js"],"names":["generateVerbExceptionForms","addSuffixesStrongVerbParadigm","dataStrongVerbs","verbClass","stems","basicSuffixes","present","suffixes","presentAllClasses","slice","pastParticiple","Array","additionalSuffixes","classDependent","allSuffixes","forms","past","stem","stemClass","push","isArray","generateFormsPerParadigm","morphologyDataVerbs","paradigm","stemmedWordToCheck","class","stemsFlattened","sort","a","b","length","includes","strongVerbs","generateFormsStrongVerbs","prefixes","verbPrefixes","stemmedWordToCheckWithoutPrefix","foundPrefix","find","startsWith","prefix","exceptions","map","word"],"mappings":"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","file":"generateVerbExceptionForms.js","sourcesContent":["import { applySuffixesToStem, applySuffixesToStems } from \"../morphoHelpers/suffixHelpers\";\nimport { flatten, forOwn, uniq as unique } from \"lodash-es\";\n\n/**\n * Adds suffixes to a given strong verb paradigm.\n *\n * @param {Object}  dataStrongVerbs The German morphology data for strong verbs.\n * @param {string}  verbClass       The verb class of the paradigm.\n * @param {Object}  stems           The stems of the paradigm.\n *\n * @returns {string[]} The created forms.\n */\nconst addSuffixesStrongVerbParadigm = function( dataStrongVerbs, verbClass, stems ) {\n\t// All classes have the same present and participle suffixes.\n\tconst basicSuffixes = {\n\t\tpresent: dataStrongVerbs.suffixes.presentAllClasses.slice(),\n\t\tpastParticiple: new Array( dataStrongVerbs.suffixes.pastParticiple ),\n\t};\n\n\t// Add class-specific suffixes.\n\tconst additionalSuffixes = dataStrongVerbs.suffixes.classDependent[ verbClass ];\n\tconst allSuffixes = { ...basicSuffixes, ...additionalSuffixes };\n\n\t// Add the present and the past stem, since these can also be forms on their own.\n\tconst forms = [ stems.present, stems.past ];\n\n\tforOwn( stems, function( stem, stemClass ) {\n\t\tforms.push(\n\t\t\tArray.isArray( stem )\n\t\t\t\t? applySuffixesToStems( stem, allSuffixes[ stemClass ] )\n\t\t\t\t: applySuffixesToStem( stem, allSuffixes[ stemClass ] )\n\t\t);\n\t} );\n\n\treturn unique( flatten( forms ) );\n};\n\n/**\n * Checks whether a verb falls into a given strong verb exception paradigm and if so,\n * returns the correct forms.\n *\n * @param {Object}  morphologyDataVerbs The German morphology data for verbs.\n * @param {Object}  paradigm            The current paradigm to generate forms for.\n * @param {string}  stemmedWordToCheck  The stem to check.\n *\n * @returns {string[]} The created verb forms.\n */\nconst generateFormsPerParadigm = function( morphologyDataVerbs, paradigm, stemmedWordToCheck ) {\n\tconst verbClass = paradigm.class;\n\tconst stems = paradigm.stems;\n\n\tlet stemsFlattened = [];\n\n\tforOwn( stems, ( stem ) => stemsFlattened.push( stem ) );\n\t// Some stem types have two forms, which means that a stem type can also contain an array. These get flattened here.\n\tstemsFlattened = flatten( stemsFlattened );\n\n\t/*\n\t * Sort in order to make sure that if the stem to check is e.g. \"gehalt\", \"halt\" isn't matched before \"gehalt\".\n\t * (Both are part of the same paradigm). Otherwise, if \"halt\" is matched, the \"ge\" will be interpreted as preceding\n\t * lexical material and added to all forms.\n\t */\n\tstemsFlattened = stemsFlattened.sort( ( a, b ) => b.length - a.length );\n\n\tif ( stemsFlattened.includes( stemmedWordToCheck ) ) {\n\t\treturn addSuffixesStrongVerbParadigm( morphologyDataVerbs.strongVerbs, verbClass, stems );\n\t}\n\n\treturn [];\n};\n\n/**\n * Checks whether a verb falls into one of the exception classes of strong verbs and if so,\n * returns the correct forms.\n *\n * @param {Object}  morphologyDataVerbs The German morphology data for verbs.\n * @param {string}  stemmedWordToCheck  The stem to check.\n *\n * @returns {string[]} The created verb forms.\n */\nconst generateFormsStrongVerbs = function( morphologyDataVerbs, stemmedWordToCheck ) {\n\tconst stems = morphologyDataVerbs.strongVerbs.stems;\n\n\tfor ( const paradigm of stems ) {\n\t\tconst forms = generateFormsPerParadigm( morphologyDataVerbs, paradigm, stemmedWordToCheck );\n\n\t\tif ( forms.length > 0 ) {\n\t\t\treturn forms;\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Checks whether a give stem stem falls into any of the verb exception categories and creates the\n * correct forms if that is the case.\n *\n * @param {Object}  morphologyDataVerbs The German morphology data for verbs.\n * @param {string}  stemmedWordToCheck  The stem to check.\n *\n * @returns {string[]} The created verb forms.\n */\nexport function generateVerbExceptionForms( morphologyDataVerbs, stemmedWordToCheck ) {\n\tconst prefixes = morphologyDataVerbs.verbPrefixes;\n\tlet stemmedWordToCheckWithoutPrefix = \"\";\n\n\tlet foundPrefix = prefixes.find( prefix => stemmedWordToCheck.startsWith( prefix ) );\n\n\tif ( typeof( foundPrefix ) === \"string\" ) {\n\t\tstemmedWordToCheckWithoutPrefix = stemmedWordToCheck.slice( foundPrefix.length );\n\t}\n\n\t// At least 3 characters so that e.g. \"be\" is not found in the stem \"berg\".\n\tif ( stemmedWordToCheckWithoutPrefix.length > 2 && typeof( foundPrefix ) === \"string\" ) {\n\t\tstemmedWordToCheck = stemmedWordToCheckWithoutPrefix;\n\t} else {\n\t\t// Reset foundPrefix so that it won't be attached when forms are generated.\n\t\tfoundPrefix = null;\n\t}\n\n\t// Check exceptions with full forms.\n\tlet exceptions = generateFormsStrongVerbs( morphologyDataVerbs, stemmedWordToCheck );\n\n\t// If the original stem had a verb prefix, attach it to the found exception forms.\n\tif ( typeof( foundPrefix ) === \"string\" ) {\n\t\texceptions = exceptions.map( word => foundPrefix + word );\n\t}\n\n\tif ( exceptions.length > 0 ) {\n\t\treturn exceptions;\n\t}\n\n\treturn exceptions;\n}\n"]}