{"version":3,"sources":["../../../../src/morphology/german/generateAdjectiveExceptionForms.js"],"names":["generateAdjectiveExceptionForms","elStemChange","morphologyDataAdjectives","stemmedWordToCheck","exceptionStems","i","length","stemPairToCheck","includes","erOnlyRestoreEr","concat","erStemChangeClass1","erStemChangeClass2","erStemChangeClass3","secondStemCompSup","bothStemsComSup","bothStemsCompSup","exceptionChecks","exceptions"],"mappings":"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","file":"generateAdjectiveExceptionForms.js","sourcesContent":["import {\n\taddAllAdjectiveSuffixes,\n\taddRegularSuffixes,\n\taddComparativeSuffixes,\n\taddSuperlativeSuffixes,\n} from \"./addAdjectiveSuffixes\";\nimport { uniq as unique } from \"lodash-es\";\n\n/**\n *  Returns forms for adjectives ending in -el that get superlative suffixes on first stem (e.g., flexibel-st)\n *  and regular and comparative suffixes on the second stem (e.g., flexibl-e, flexibl-er).\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nconst elStemChange = function( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionStems = morphologyDataAdjectives.elStemChange;\n\n\tfor ( let i = 0; i < exceptionStems.length; i++ ) {\n\t\tconst stemPairToCheck = exceptionStems[ i ];\n\n\t\tif ( stemPairToCheck.includes( stemmedWordToCheck ) ) {\n\t\t\treturn [\n\t\t\t\tstemPairToCheck[ 0 ],\n\t\t\t\t...addSuperlativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 0 ] ),\n\t\t\t\t...addRegularSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t\t...addComparativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t];\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Returns forms for adjectives ending in -er. These get the -er re-attached after the stemmer has deleted it and\n * subsequently get all suffixes attached.\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nconst erOnlyRestoreEr = function( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionStems = morphologyDataAdjectives.erOnlyRestoreEr;\n\n\n\tif ( exceptionStems.includes( stemmedWordToCheck ) ) {\n\t\t/*\n\t\t * Since the stemmer incorrectly removes -er, we need to add it again here. Subsequently we add\n\t\t * all adjective endings to the stem with the restored -er.\n\t\t */\n\t\treturn [\n\t\t\tstemmedWordToCheck.concat( \"er\" ),\n\t\t\t...addAllAdjectiveSuffixes( morphologyDataAdjectives, stemmedWordToCheck.concat( \"er\" ) ),\n\t\t];\n\t}\n\n\treturn [];\n};\n\n/**\n * Returns forms for adjectives ending in -er that have two stems: the -er stem gets restored and receives\n * regular and superlative endings (e.g., makaber-e, makaber-ste ); the -r stem receives comparative endings (e.g., makabr-er).\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nconst erStemChangeClass1 = function( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionStems = morphologyDataAdjectives.erStemChangeClass1;\n\n\tfor ( let i = 0; i < exceptionStems.length; i++ ) {\n\t\tconst stemPairToCheck = exceptionStems[ i ];\n\n\t\tif ( stemPairToCheck.includes( stemmedWordToCheck ) ) {\n\t\t\treturn unique( [\n\t\t\t\tstemPairToCheck[ 0 ].concat( \"er\" ),\n\t\t\t\t...addRegularSuffixes( morphologyDataAdjectives, stemPairToCheck[ 0 ].concat( \"er\" ) ),\n\t\t\t\t...addSuperlativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 0 ].concat( \"er\" ) ),\n\t\t\t\t...addComparativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t] );\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Returns forms for adjectives ending in -er that have two stems: the -er stem gets restored and\n * receives superlative endings (e.g., sauer-ste) the -r stem receives regular and comparative endings\n * (e.g., saur-e, saur-er).\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nconst erStemChangeClass2 = function( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionStems = morphologyDataAdjectives.erStemChangeClass2;\n\n\tfor ( let i = 0; i < exceptionStems.length; i++ ) {\n\t\tconst stemPairToCheck = exceptionStems[ i ];\n\n\t\tif ( stemPairToCheck.includes( stemmedWordToCheck ) ) {\n\t\t\treturn unique( [\n\t\t\t\tstemPairToCheck[ 0 ].concat( \"er\" ),\n\t\t\t\t...addSuperlativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 0 ].concat( \"er\" ) ),\n\t\t\t\t...addRegularSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t\t...addComparativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t] );\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Returns forms for adjectives ending in -er that have two stems: the -er stem gets restored and receives regular,\n * comparative and superlative endings (e.g., finster-e, finster-er, finster-ste); the -r stem receives comparative endings\n * (e.g., finstr-er).\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nconst erStemChangeClass3 = function( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionStems = morphologyDataAdjectives.erStemChangeClass3;\n\n\tfor ( let i = 0; i < exceptionStems.length; i++ ) {\n\t\tconst stemPairToCheck = exceptionStems[ i ];\n\n\t\tif ( stemPairToCheck.includes( stemmedWordToCheck ) ) {\n\t\t\treturn unique( [\n\t\t\t\tstemPairToCheck[ 0 ].concat( \"er\" ),\n\t\t\t\t...addAllAdjectiveSuffixes( morphologyDataAdjectives, stemPairToCheck[ 0 ].concat( \"er\" ) ),\n\t\t\t\t...addComparativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t] );\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Returns forms for adjectives that get the regular suffixes on their first stem (e.g., gesund-e) and the comparative and\n * superlative suffixes on their second stem (e.g., gesünd-er, gesünd-est).\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nconst secondStemCompSup = function( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionStems = morphologyDataAdjectives.secondStemCompSup;\n\n\tfor ( let i = 0; i < exceptionStems.length; i++ ) {\n\t\tconst stemPairToCheck = exceptionStems[ i ];\n\n\t\tif ( stemPairToCheck.includes( stemmedWordToCheck ) ) {\n\t\t\treturn unique( [\n\t\t\t\t...addRegularSuffixes( morphologyDataAdjectives, stemPairToCheck[ 0 ] ),\n\t\t\t\t...addComparativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t\t...addSuperlativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t] );\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Returns forms for adjectives that get all suffixes on the first stem (e.g., blass-e, blass-er, blass-est)\n * and only the comparative and superlative suffixes on the second (bläss-er, bläss-est).\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nconst bothStemsComSup = function( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionStems = morphologyDataAdjectives.bothStemsCompSup;\n\n\tfor ( let i = 0; i < exceptionStems.length; i++ ) {\n\t\tconst stemPairToCheck = exceptionStems[ i ];\n\n\t\tif ( stemPairToCheck.includes( stemmedWordToCheck ) ) {\n\t\t\treturn unique( [\n\t\t\t\t...addAllAdjectiveSuffixes( morphologyDataAdjectives, stemPairToCheck[ 0 ] ),\n\t\t\t\t...addComparativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t\t...addSuperlativeSuffixes( morphologyDataAdjectives, stemPairToCheck[ 1 ] ),\n\t\t\t] );\n\t\t}\n\t}\n\n\treturn [];\n};\n\n/**\n * Checks whether a give stem stem falls into any of the adjective exception categories and creates the\n * correct forms if that is the case.\n *\n * @param {Object}  morphologyDataAdjectives The German morphology data for adjectives.\n * @param {string}  stemmedWordToCheck       The stem to check.\n *\n * @returns {string[]} The created adjective forms.\n */\nexport function generateAdjectiveExceptionForms( morphologyDataAdjectives, stemmedWordToCheck ) {\n\tconst exceptionChecks = [\n\t\telStemChange,\n\t\terOnlyRestoreEr,\n\t\t/*\n\t\t * Within the group of adjectives ending in -er with two stems, there are different classes\n\t\t * of adjectives with regards to what endings they get on which stem.\n\t\t */\n\t\terStemChangeClass1,\n\t\terStemChangeClass2,\n\t\terStemChangeClass3,\n\t\tsecondStemCompSup,\n\t\tbothStemsComSup,\n\t];\n\n\tfor ( let i = 0; i < exceptionChecks.length; i++ ) {\n\t\tconst exceptions = exceptionChecks[ i ]( morphologyDataAdjectives, stemmedWordToCheck );\n\t\tif ( exceptions.length > 0 ) {\n\t\t\treturn exceptions;\n\t\t}\n\t}\n\n\treturn [];\n}\n"]}