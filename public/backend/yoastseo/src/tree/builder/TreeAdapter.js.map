{"version":3,"sources":["../../../../src/tree/builder/TreeAdapter.js"],"names":["TreeAdapter","tag","namespace","attributes","node","ignoredHtmlElements","includes","Ignored","formattingElements","parsedAttributes","_parseAttributes","FormattingElement","_parseNode","tagName","parent","StructuredNode","text","content","child","_isStructuredElement","LeafNode","element","location","_appendFormattingElement","children","push","index","indexOf","splice","textContainer","appendText","_addFormattingElementText","_addStructuredNodeText","documentMode","mode","length","headings","Heading","parseInt","Paragraph","List","ListItem","parse5attributes","reduce","attribute","name","value","formattingElement","prevChild","isExplicit","formatting","_addOrphanedFormattingElement","ancestor","_findAncestorLeafNode","paragraph"],"mappings":"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","file":"TreeAdapter.js","sourcesContent":["// Tree elements.\nimport FormattingElement from \"../structure/FormattingElement\";\nimport Heading from \"../structure/nodes/Heading\";\nimport LeafNode from \"../structure/nodes/LeafNode\";\nimport List from \"../structure/nodes/List\";\nimport ListItem from \"../structure/nodes/ListItem\";\nimport Paragraph from \"../structure/nodes/Paragraph\";\nimport Ignored from \"../structure/nodes/Ignored\";\nimport StructuredNode from \"../structure/nodes/StructuredNode\";\n// HTML classes.\nimport { formattingElements, headings, ignoredHtmlElements } from \"./htmlConstants\";\n\n/**\n * An adapter to parse the HTML source code to a structured tree representation, to be used in further analysis,\n * in combination with the `parse5` library.\n *\n * Implements the `parse5` library's `TreeAdapter` interface.\n * @see https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/tree-adapter/interface.md\n *\n * @memberOf module:tree/builder\n *\n * @private\n */\nclass TreeAdapter {\n\t// Creation of nodes and other tree elements.\n\n\t/**\n\t * Creates a new element to be put in the tree.\n\t *\n\t * @param {string} tag                                        The HTML tag.\n\t * @param {string} namespace                                  The XML namespace (e.g. \"http://www.w3.org/1999/xhtml\" for HTML).\n\t * @param {Array<{ name: string, value: string }>} attributes The attributes of this element.\n\t *\n\t * @returns {module:tree/structure.Node|module:tree/structure.FormattingElement} The new element.\n\t */\n\tcreateElement( tag, namespace, attributes ) {\n\t\tlet node;\n\n\t\tif ( ignoredHtmlElements.includes( tag ) ) {\n\t\t\t// Ignored for analysis (e.g. `script`, `style`).\n\t\t\tnode = new Ignored( tag );\n\t\t} else if ( formattingElements.includes( tag ) ) {\n\t\t\t// Formatting element.\n\t\t\tconst parsedAttributes = TreeAdapter._parseAttributes( attributes );\n\t\t\tnode = new FormattingElement( tag, parsedAttributes );\n\t\t} else {\n\t\t\t// Paragraphs, Headers, Lists, ListItems and other nodes.\n\t\t\tnode = TreeAdapter._parseNode( tag );\n\t\t}\n\n\t\t/*\n\t\t  We need to add the tag name for `parse5`\n\t\t  to track the still open HTML elements correctly.\n\t\t  (E.g. when it encounters a closing tag, it know which element needs to be closed).\n\t\t */\n\t\tnode.tagName = tag;\n\t\tnode.namespace = namespace;\n\t\tnode.parent = null;\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Makes a new node to add to the tree, based on the given HTML-tag.\n\t *\n\t * @param {string} tag The HTML-tag of the element to add.\n\t *\n\t * @returns {module:tree/structure.Node} The node to add to the tree.\n\t *\n\t * @private\n\t */\n\tstatic _parseNode( tag ) {\n\t\tif ( headings.includes( tag ) ) {\n\t\t\t// Heading.\n\t\t\treturn new Heading( parseInt( tag[ 1 ], 10 ) );\n\t\t} else if ( tag === \"p\" ) {\n\t\t\t// Paragraph.\n\t\t\treturn new Paragraph( tag );\n\t\t} else if ( tag === \"ol\" || tag === \"ul\" ) {\n\t\t\t// List.\n\t\t\treturn new List( tag === \"ol\" );\n\t\t} else if ( tag === \"li\" ) {\n\t\t\t// List item.\n\t\t\treturn new ListItem();\n\t\t}\n\t\t// All other elements (`div`, `section`).\n\t\treturn new StructuredNode( tag );\n\t}\n\n\t/**\n\t * Parses the HTML element attributes from parse5's format to a plain JS object.\n\t * E.g. `{ name: \"id\", value: \"an-id\" }` becomes ` { id: \"an-id\" }`.\n\t *\n\t * @param {Array<{ name: string, value: string }>} parse5attributes The attributes as parsed by parse5.\n\t *\n\t * @returns {Object} The parsed attributes.\n\t *\n\t * @private\n\t */\n\tstatic _parseAttributes( parse5attributes ) {\n\t\tif ( parse5attributes && parse5attributes.length > 0 ) {\n\t\t\treturn parse5attributes.reduce( ( attributes, attribute ) => {\n\t\t\t\tattributes[ attribute.name ] = attribute.value;\n\t\t\t\treturn attributes;\n\t\t\t}, {} );\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Creates a new empty document fragment (e.g. a part of an HTML document).\n\t *\n\t * @returns {StructuredNode} A new empty document fragment.\n\t */\n\tcreateDocumentFragment() {\n\t\treturn new StructuredNode( \"root\" );\n\t}\n\n\t/**\n\t * Creates a new node representing an HTML-comment.\n\t *\n\t * @param {string} text The comment text.\n\t *\n\t * @returns {Ignored} The node representing the comment.\n\t */\n\tcreateCommentNode( text ) {\n\t\tconst node = new Ignored( \"comment\" );\n\t\tnode.parent = null;\n\t\tnode.content = text;\n\t\treturn node;\n\t}\n\n\t// Tree manipulation.\n\n\t/**\n\t * Appends a child node to a parent node.\n\t *\n\t * @param {Node} parent The parent node.\n\t * @param {Node} child  The child to add to the parent node.\n\t *\n\t * @returns {void}\n\t */\n\tappendChild( parent, child ) {\n\t\t/*\n\t\t  Do not do anything with ignored content.\n\t\t  (We get the raw string contents later on from the source code).\n\t\t */\n\t\tif ( parent instanceof Ignored ) {\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t  Structured (ignored) nodes can also be contained within headings, paragraphs\n\t\t  and formatting elements, even though it is not entirely valid HTML,\n\t\t  so we need to transform it to a FormattingElement and add it\n\t\t  to the appropriate heading or paragraph ancestor.\n\t\t */\n\t\tif ( TreeAdapter._isStructuredElement( child ) &&\n\t\t\t( parent instanceof FormattingElement || parent instanceof LeafNode ) ) {\n\t\t\t// Add structured (ignored) node as formatting to the first header or paragraph ancestor.\n\t\t\tconst element = new FormattingElement( child.tagName );\n\t\t\telement.location = child.location;\n\t\t\tTreeAdapter._appendFormattingElement( parent, element );\n\t\t\treturn;\n\t\t}\n\n\t\t// Add formatting element to its first ancestor that is either a heading or paragraph.\n\t\tif ( child instanceof FormattingElement ) {\n\t\t\tTreeAdapter._appendFormattingElement( parent, child );\n\t\t\treturn;\n\t\t}\n\n\t\t// Just add nodes to parent's children in any other case.\n\t\tchild.parent = parent;\n\t\tparent.children.push( child );\n\t}\n\n\t/**\n\t * Appends the formatting element to the tree.\n\t *\n\t * @param {Node} parent                          The (current) parent of the formatting element.\n\t * @param {FormattingElement} formattingElement  The formatting element to add to the tree.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _appendFormattingElement( parent, formattingElement ) {\n\t\tformattingElement.parent = parent;\n\t\tif ( parent instanceof StructuredNode ) {\n\t\t\t/*\n\t\t\t  If the previous child is an implicit paragraph (\"[p]\"),\n\t\t\t  we should add the formatting element to it, instead of making a new paragraph.\n\n\t\t\t  E.g. in the case of `<div>[p]Hello [/p]<em>World!</em></div>`,\n\t\t\t  \"<em>World!</em>\" should be added to \"[p]Hello [p]\".\n\t\t\t */\n\t\t\tconst prevChild = parent.children[ parent.children.length - 1 ];\n\t\t\tif ( prevChild && prevChild instanceof Paragraph && ! prevChild.isExplicit() ) {\n\t\t\t\t// Add it to the implicit paragraph.\n\t\t\t\tprevChild.textContainer.formatting.push( formattingElement );\n\t\t\t\tformattingElement.parent = prevChild;\n\t\t\t} else {\n\t\t\t\t// Wrap it in a new implicit paragraph, add it as formatting.\n\t\t\t\tTreeAdapter._addOrphanedFormattingElement( parent, formattingElement );\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t Formatting elements can be nested, we want to add it to\n\t\t\t the most recent ancestor which is either a heading or paragraph.\n\t\t\t */\n\t\t\tconst ancestor = TreeAdapter._findAncestorLeafNode( formattingElement );\n\t\t\tif ( ancestor ) {\n\t\t\t\t// Add formatting element as formatting to the found paragraph or heading ancestor.\n\t\t\t\tformattingElement.parent = parent;\n\t\t\t\tancestor.textContainer.formatting.push( formattingElement );\n\t\t\t} else {\n\t\t\t\t// Wrap formatting element in paragraph, add it to the tree.\n\t\t\t\tTreeAdapter._addOrphanedFormattingElement( parent, formattingElement );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Wraps a formatting element in a paragraph and adds the resulting paragraph to the given parent.\n\t *\n\t * @param {Node} parent                          The parent element to add the new paragraph to.\n\t * @param {FormattingElement} formattingElement  The formatting element to wrap in a paragraph and add to the tree.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _addOrphanedFormattingElement( parent, formattingElement ) {\n\t\tconst paragraph = new Paragraph();\n\t\tparagraph.location = formattingElement.location;\n\n\t\tparagraph.textContainer.formatting.push( formattingElement );\n\n\t\tparagraph.parent = parent;\n\t\tformattingElement.parent = paragraph;\n\t\tparent.children.push( paragraph );\n\t}\n\n\t/**\n\t * Detaches a node from its parent.\n\t *\n\t * @param {Node} node The node to detach from its parent.\n\t *\n\t * @returns {void}\n\t */\n\tdetachNode( node ) {\n\t\tif ( node.parent ) {\n\t\t\tconst index = node.parent.children.indexOf( node );\n\t\t\tnode.parent.children.splice( index, 1 );\n\t\t\tnode.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Appends text to a node in the tree.\n\t *\n\t * To which node it is appended depends on a few factors:\n\t *  1. If its parent is a paragraph or header: append the text to its text container.\n\t *  2. If its parent is a structured node: wrap text in a paragraph, add paragraph to parent.\n\t *  3. If its parent is a formatting element: append text to the most recent ancestor who is a paragraph or heading.\n\t *\n\t * @param {Node} node   The node to (try to) append the text to.\n\t * @param {string} text The text to append to the node.\n\t *\n\t * @returns {void}\n\t */\n\tinsertText( node, text ) {\n\t\t// Do not add text to ignored nodes. We are going to add it later from the source text.\n\t\tif ( node instanceof Ignored ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( node instanceof LeafNode ) {\n\t\t\t// Node may only contain formatting elements.\n\t\t\tnode.textContainer.appendText( text );\n\t\t} else if ( node instanceof FormattingElement ) {\n\t\t\tTreeAdapter._addFormattingElementText( node, text );\n\t\t} else {\n\t\t\tTreeAdapter._addStructuredNodeText( node, text );\n\t\t}\n\t}\n\n\t/**\n\t * Appends the given text to the formatting element's most recent ancestor\n\t * who is either a paragraph or a heading.\n\t *\n\t * @param {FormattingElement} formattingElement The formatting element.\n\t * @param {string} text                         The text to add.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _addFormattingElementText( formattingElement, text ) {\n\t\t// Find a paragraph or header ancestor.\n\t\tconst ancestor = TreeAdapter._findAncestorLeafNode( formattingElement );\n\t\t// Append text to ancestor's text container.\n\t\tif ( ancestor ) {\n\t\t\tancestor.textContainer.appendText( text );\n\t\t}\n\t}\n\n\t/**\n\t * Appends the given text to either:\n\t *  1. The node's most recent child, if it is a paragraph or a heading.\n\t *  2. A new paragraph, if not.\n\t *\n\t * @param {StructuredNode} node The node.\n\t * @param {string} text         The text to append.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\tstatic _addStructuredNodeText( node, text ) {\n\t\t// Get the previous sibling of this node.\n\t\tconst prevChild = node.children[ node.children.length - 1 ];\n\t\t/*\n\t\t  If the previous child is an implicit paragraph, append the text to it,\n\t\t  instead of creating a new one in the explicit case.\n\n\t\t  E.g. implicit case: \"This is a \" + \"paragraph\" => \"This is a paragraph\"\n\t\t  Explicit case: \"<p>This is not a <p>\" + \"paragraph\" => \"<p>This is not a <p>paragraph\"\n\t\t */\n\t\tif ( prevChild && prevChild instanceof Paragraph && ! prevChild.isExplicit() ) {\n\t\t\t// Append text to the paragraph.\n\t\t\tprevChild.textContainer.appendText( text );\n\t\t} else {\n\t\t\t// Else: wrap the text in an implicit paragraph and add it as a new child.\n\t\t\tconst paragraph = new Paragraph();\n\t\t\tparagraph.textContainer.appendText( text );\n\t\t\tparagraph.parent = node;\n\t\t\tnode.children.push( paragraph );\n\t\t}\n\t}\n\n\t// Node getters and setters.\n\n\t/**\n\t * Returns this node's tag name.\n\t * (e.g. \"h1\", \"p\", \"comment\", \"h3\", \"div\")\n\t *\n\t * This is used by `parse5` to be able to differentiate between different\n\t * behavior of HTML elements.\n\t *\n\t * @param {Node} node The node to get the tag name from.\n\t *\n\t * @returns {string} The node's tag name.\n\t */\n\tgetTagName( node ) {\n\t\treturn node.tagName;\n\t}\n\n\t/**\n\t * Returns this node's namespace URI.\n\t * (e.g. \"http://www.w3.org/1999/xhtml\" for HTML)\n\t *\n\t * This is used by `parse5` to differentiate between parsing\n\t * HTML, SVG and other XML schema types.\n\t *\n\t * @param {Node} node The node to get the namespace URI from.\n\t *\n\t * @returns {string} The namespace URI of this node.\n\t */\n\tgetNamespaceURI( node ) {\n\t\treturn node.namespace;\n\t}\n\n\t/**\n\t * Gets the mode of the given element (e.g. \"quirks\", \"no-quirks\" or \"limited-quirks\").\n\t *\n\t * This is needed by the `parse5` library to be able to parse certain texts.\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode\n\t *\n\t * @param {module:tree/structure.Node} element The element to set the mode of.\n\t *\n\t * @returns {void}\n\t */\n\tgetDocumentMode( element ) {\n\t\treturn element.documentMode;\n\t}\n\n\t/**\n\t * Sets the mode of the given element (e.g. \"quirks\", \"no-quirks\" or \"limited-quirks\").\n\t *\n\t * This is needed by the `parse5` library to be able to parse certain texts.\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode\n\t *\n\t * @param {module:tree/structure.Node} element         The element to set the mode of.\n\t * @param {\"no-quirks\"|\"quirks\"|\"limited-quirks\"} mode The mode to set.\n\t *\n\t * @returns {void}\n\t */\n\tsetDocumentMode( element, mode ) {\n\t\telement.documentMode = mode;\n\t}\n\n\n\t/**\n\t * Returns this node's parent node.\n\t *\n\t * @param {Node} node The node from which to retrieve the parent.\n\t *\n\t * @returns {Node} The parent of this node.\n\t */\n\tgetParentNode( node ) {\n\t\treturn node.parent;\n\t}\n\n\t/**\n\t * Returns the children of the given node.\n\t *\n\t * If the node does not have any children and cannot get any (e.g. Heading, FormattingElement)\n\t * this function returns an empty list.\n\t *\n\t * @param {Node} node The node to get the children from.\n\t *\n\t * @returns {Node[]} The children of the given node.\n\t */\n\tgetChildNodes( node ) {\n\t\t/*\n\t\t  Some node types do not have children (like Paragraph and Heading),\n\t\t  but parse5 always expects a node to have children.\n\t\t */\n\t\treturn node.children || [];\n\t}\n\n\t/**\n\t * Gets a parent's first child.\n\t *\n\t * @see https://en.wikipedia.org/wiki/Rumpelstiltskin\n\t *\n\t * @param {Node} node The node to get its first child from.\n\t *\n\t * @returns {Node[]|null} The node's first child or null, if this node cannot get any children.\n\t */\n\tgetFirstChild( node ) {\n\t\tif ( node.children && node.children.length > 0 ) {\n\t\t\treturn node.children[ 0 ];\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Node source location.\n\n\t/**\n\t * Sets the node's location as found in the source code.\n\t *\n\t * More often than not this is not the entire info\n\t * and misses the location of the end tag...\n\t *\n\t * We still need to add it, since `parse5` appends the end tag position\n\t * to this object somewhere during parsing (after `createElement` and before `appendChild`).\n\t *\n\t * @param {Node} node         The node to set its location.\n\t * @param {Location} location The node's location in the source code.\n\t *\n\t * @returns {void}\n\t */\n\tsetNodeSourceCodeLocation( node, location ) {\n\t\tif ( ! node ) {\n\t\t\treturn;\n\t\t}\n\t\tnode.location = location;\n\t}\n\n\t/**\n\t * Gets the node's source code location.\n\t *\n\t * @param {Node} node The node to get its source code location from.\n\t *\n\t * @returns {Location|void} The node's source code location.\n\t */\n\tgetNodeSourceCodeLocation( node ) {\n\t\tif ( ! node ) {\n\t\t\treturn;\n\t\t}\n\t\treturn node.location;\n\t}\n\n\t// Private utility methods.\n\n\t/**\n\t * Finds the most recent leaf node ancestor (parent of parent of ... ) of the given element.\n\t * (A leaf node is a node that may only contain text and formatting elements, like a heading or a paragraph).\n\t *\n\t * @see module:tree/structure.LeafNode.\n\t *\n\t * @param {Node|FormattingElement} element  The node to find the ancestor of.\n\t *\n\t * @returns {Node|null} The most recent ancestor that returns true on the given predicate, or `null` if no appropriate ancestor is found.\n\t *\n\t * @private\n\t */\n\tstatic _findAncestorLeafNode( element ) {\n\t\tlet parent = element.parent;\n\t\t/*\n\t\t  Go up the tree until we either find the element we want,\n\t\t  or until we are at the root of the tree (an element with no parent).\n\t\t */\n\t\twhile ( ! ( parent instanceof LeafNode ) && parent !== null ) {\n\t\t\tparent = parent.parent;\n\t\t}\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Checks whether the given element is either a structured or ignored node.\n\t *\n\t * @param {Node} element The element to check.\n\t *\n\t * @returns {boolean} `true` if the element is indeed a structured element.\n\t *\n\t * @private\n\t */\n\tstatic _isStructuredElement( element ) {\n\t\treturn element instanceof StructuredNode || element instanceof Ignored;\n\t}\n}\n\nexport default TreeAdapter;\n"]}