{"version":3,"sources":["../../../../../src/tree/builder/cleanup/postParsing.js"],"names":["calculateSourceIndices","element","location","sourceStartIndex","startOffset","sourceEndIndex","endOffset","deleteParseParameters","namespace","tagName","documentMode","cleanUpNode","node","html","Ignored","content","LeafNode","textContainer","formatting","map","setEndIndexRootNode","tree","endIndexRootNode","forEach","Math","max","cleanUpTree"],"mappings":";;;;;;AAAA;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;;;;;;;;AAUA,IAAMA,yBAAyB,SAAzBA,sBAAyB,CAAUC,OAAV,EAAoB;AAClD,MAAKA,QAAQC,QAAb,EAAwB;AACvBD,YAAQE,gBAAR,GAA2BF,QAAQC,QAAR,CAAiBE,WAA5C;AACAH,YAAQI,cAAR,GAAyBJ,QAAQC,QAAR,CAAiBI,SAA1C;AACA;AACD,CALD;;AAOA;;;;;;;;;;AAUA,IAAMC,wBAAwB,SAAxBA,qBAAwB,CAAUN,OAAV,EAAoB;AACjD,SAAOA,QAAQC,QAAf;AACA,SAAOD,QAAQO,SAAf;AACA,SAAOP,QAAQQ,OAAf;AACA,SAAOR,QAAQS,YAAf;AACA,CALD;;AAOA;;;;;;;;;;AAUA,IAAMC,cAAc,SAAdA,WAAc,CAAUC,IAAV,EAAgBC,IAAhB,EAAuB;AAC1C;AACA,MAAKD,gBAAgBE,iBAArB,EAA+B;AAC9BF,SAAKG,OAAL,GAAe,iCAAmBH,IAAnB,EAAyBC,IAAzB,CAAf;AACA;;AAED;AACA,MAAKD,gBAAgBI,mBAArB,EAAgC;AAC/B;AACA,wCAAsBJ,IAAtB,EAA4BC,IAA5B;AACAD,SAAKK,aAAL,CAAmBC,UAAnB,GAAgCN,KAAKK,aAAL,CAAmBC,UAAnB,CAA8BC,GAA9B,CAAmC,mBAAW;AAC7E;AACAnB,6BAAwBC,OAAxB;AACAM,4BAAuBN,OAAvB;;AAEA,aAAOA,OAAP;AACA,KAN+B,CAAhC;AAOA;;AAEDD,yBAAwBY,IAAxB;AACAL,wBAAuBK,IAAvB;;AAEA,SAAOA,IAAP;AACA,CAvBD;;AAyBA;;;;;;;;;AASA,IAAMQ,sBAAsB,SAAtBA,mBAAsB,CAAUC,IAAV,EAAiB;AAC5C,MAAIC,mBAAmB,CAAvB;AACAD,OAAKE,OAAL,CAAc,gBAAQ;AACrBD,uBAAmBE,KAAKC,GAAL,CAAUb,KAAKP,cAAf,EAA+BiB,gBAA/B,CAAnB;AACA,GAFD;AAGAD,OAAKhB,cAAL,GAAsBiB,gBAAtB;AACA,CAND;;AAQA;;;;;;;;;;;;;AAaA,IAAMI,cAAc,SAAdA,WAAc,CAAUL,IAAV,EAAgBR,IAAhB,EAAuB;AAC1CQ,OAAKF,GAAL,CAAU;AAAA,WAAQR,YAAaC,IAAb,EAAmBC,IAAnB,CAAR;AAAA,GAAV;AACAO,sBAAqBC,IAArB;AACA,SAAOA,IAAP;AACA,CAJD;;kBAMeK,W","file":"postParsing.js","sourcesContent":["import { LeafNode } from \"../../structure\";\nimport Ignored from \"../../structure/nodes/Ignored\";\nimport calculateTextIndices from \"./calculateTextIndices\";\nimport getElementContent from \"./getElementContent\";\n\n/**\n * Calculates the start and end index of the given node or formatting element,\n * based on its source code location as parsed by `parse5`.\n *\n * @param {module:tree/structure.Node|module:tree/structure.FormattingElement} element  The element to set the start and end index of\n *\n * @returns {void}\n *\n * @private\n */\nconst calculateSourceIndices = function( element ) {\n\tif ( element.location ) {\n\t\telement.sourceStartIndex = element.location.startOffset;\n\t\telement.sourceEndIndex = element.location.endOffset;\n\t}\n};\n\n/**\n * Deletes parameters from the element that are used during parsing,\n * but are not needed for analysis.\n *\n * @param {Object} element  The element to delete parameters of.\n *\n * @returns {void}\n *\n * @private\n */\nconst deleteParseParameters = function( element ) {\n\tdelete element.location;\n\tdelete element.namespace;\n\tdelete element.tagName;\n\tdelete element.documentMode;\n};\n\n/**\n * Cleans up a node in the tree.\n *\n * @param {module:tree/structure.Node} node The node that needs to be cleaned.\n * @param {string} html                     The original html source code from which the node has been parsed.\n *\n * @returns {module:tree/structure.Node} The cleaned up node.\n *\n * @private\n */\nconst cleanUpNode = function( node, html ) {\n\t// Set content of ignored node, based on original source code.\n\tif ( node instanceof Ignored ) {\n\t\tnode.content = getElementContent( node, html );\n\t}\n\n\t// Clean up formatting elements in headings and paragraphs.\n\tif ( node instanceof LeafNode ) {\n\t\t// Start and end position in leaf node's (header's or paragraph's) text without formatting.\n\t\tcalculateTextIndices( node, html );\n\t\tnode.textContainer.formatting = node.textContainer.formatting.map( element => {\n\t\t\t// Start and end position in text **with** formatting.\n\t\t\tcalculateSourceIndices( element );\n\t\t\tdeleteParseParameters( element );\n\n\t\t\treturn element;\n\t\t} );\n\t}\n\n\tcalculateSourceIndices( node );\n\tdeleteParseParameters( node );\n\n\treturn node;\n};\n\n/**\n * Sets the end index of the root node to the end of the text.\n *\n * @param {module:tree/structure.Node} tree The tree of which to set the root node's end index.\n *\n * @returns {void}\n *\n * @private\n */\nconst setEndIndexRootNode = function( tree ) {\n\tlet endIndexRootNode = 0;\n\ttree.forEach( node => {\n\t\tendIndexRootNode = Math.max( node.sourceEndIndex, endIndexRootNode );\n\t} );\n\ttree.sourceEndIndex = endIndexRootNode;\n};\n\n/**\n * Cleans up the given tree after parsing of the HTML source code.\n *\n * These steps are setting the start and end index of each node and\n * deleting attributes needed for parsing, but not needed for further analysis.\n *\n * @param {module:tree/structure.Node} tree The tree structure to be cleaned.\n * @param {string} html                     The original HTML source code.\n *\n * @returns {module:tree/structure.Node} The cleaned up tree.\n *\n * @private\n */\nconst cleanUpTree = function( tree, html ) {\n\ttree.map( node => cleanUpNode( node, html ) );\n\tsetEndIndexRootNode( tree );\n\treturn tree;\n};\n\nexport default cleanUpTree;\n"]}