{"version":3,"sources":["../../../../src/tree/assess/TreeAssessor.js"],"names":["TreeAssessor","options","i18n","researcher","scoreAggregator","_assessments","assessments","forEach","assessment","setResearcher","paper","node","applicableAssessments","getApplicableAssessments","results","Promise","all","map","applyAssessment","validResults","filter","result","getScore","score","aggregate","apply","catch","AssessmentResult","text","sprintf","dgettext","name","push","index","findIndex","deleted","splice","assessmentToReturn","find","promises","isApplicable","then","applicable"],"mappings":"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","file":"TreeAssessor.js","sourcesContent":["import AssessmentResult from \"../../values/AssessmentResult\";\n\n/**\n * Analyzes a paper by doing a list of assessments on a tree representation of a text and its metadata.\n * Aggregates the scores on each individual assessment into an overall score.\n *\n * This score can represent anything from the readability to the SEO of the given text and metadata.\n *\n * @memberOf module:tree/assess\n */\nclass TreeAssessor {\n\t/**\n\t * Creates a new assessor.\n\t *\n\t * @param {Object}                              options                 Assessor options.\n\t * @param {Jed}                                 options.i18n            A Jed object to use for translations.\n\t * @param {module:tree/research.TreeResearcher} options.researcher      Supplies the assessments with researches and their (cached) results.\n\t * @param {module:tree/assess.ScoreAggregator}  options.scoreAggregator Aggregates the scores on the individual assessments into one.\n\t * @param {module:tree/assess.Assessment[]}     [options.assessments]   The list of assessments to apply.\n\t */\n\tconstructor( options ) {\n\t\t/**\n\t\t * A Jed object to use for translations.\n\t\t * @type {Jed}\n\t\t */\n\t\tthis.i18n = options.i18n;\n\t\t/**\n\t\t * Supplies the assessments with researches and their (cached) results.\n\t\t * @type {module:tree/research.TreeResearcher}\n\t\t */\n\t\tthis.researcher = options.researcher;\n\t\t/**\n\t\t * Aggregates the scores on the individual assessments into one overall score.\n\t\t * @type {module:tree/assess.ScoreAggregator}\n\t\t */\n\t\tthis.scoreAggregator = options.scoreAggregator;\n\t\t/**\n\t\t * The list of assessments to apply.\n\t\t * @type {module:tree/assess.Assessment[]}\n\t\t */\n\t\tthis._assessments = options.assessments || [];\n\t\t// Make sure that all of the assessments have the researcher.\n\t\tthis._assessments.forEach( assessment => assessment.setResearcher( this.researcher ) );\n\t}\n\n\t/**\n\t * Returns the list of available assessments.\n\t *\n\t * @returns {module:tree/assess.Assessment[]} The list of all available assessments.\n\t */\n\tgetAssessments() {\n\t\treturn this._assessments;\n\t}\n\n\t/**\n\t * Assesses the given text by applying all the assessments to it\n\t * and aggregating the resulting scores.\n\t *\n\t * @param {Paper}                      paper The paper to assess. This contains metadata about the text.\n\t * @param {module:tree/structure.Node} node  The root node of the tree to check.\n\t *\n\t * @returns {Promise<{results: AssessmentResult[], score: number}>} The assessment results and the overall score.\n\t */\n\tasync assess( paper, node ) {\n\t\tconst applicableAssessments = await this.getApplicableAssessments( paper, node );\n\t\t/*\n\t\t  Apply every applicable assessment on the document.\n\t\t  Wait before they are done before aggregating the results\n\t\t  and returning the results and final score.\n\t\t */\n\t\tconst results = await Promise.all(\n\t\t\tapplicableAssessments.map( assessment => this.applyAssessment( assessment, paper, node ) )\n\t\t);\n\t\t// Filter out errored assessments.\n\t\tconst validResults = results.filter( result => result.getScore() !== -1 );\n\t\t// Compute overall score.\n\t\tconst score = this.scoreAggregator.aggregate( validResults );\n\n\t\treturn { results, score };\n\t}\n\n\t/**\n\t * Applies the given assessment to the paper-node combination.\n\t *\n\t * @param {module:tree/assess.Assessment} assessment The assessment to apply.\n\t * @param {Paper}                         paper      The paper to apply the assessment to.\n\t * @param {module:tree/structure.Node}    node       The root node of the tree to apply the assessment to.\n\t *\n\t * @returns {Promise<AssessmentResult>} The result of the assessment.\n\t */\n\tasync applyAssessment( assessment, paper, node ) {\n\t\treturn assessment.apply( paper, node ).catch(\n\t\t\t() => {\n\t\t\t\treturn new AssessmentResult( {\n\t\t\t\t\ttext: this.i18n.sprintf(\n\t\t\t\t\t\t/* Translators: %1$s expands to the name of the assessment. */\n\t\t\t\t\t\tthis.i18n.dgettext( \"js-text-analysis\", \"An error occurred in the '%1$s' assessment\" ),\n\t\t\t\t\t\tassessment.name,\n\t\t\t\t\t),\n\t\t\t\t\tscore: -1,\n\t\t\t\t} );\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Adds the assessment to the list of assessments to apply.\n\t *\n\t * @param {string}                        name       The name to register the assessment under.\n\t * @param {module:tree/assess.Assessment} assessment The assessment to add.\n\t *\n\t * @returns {void}\n\t */\n\tregisterAssessment( name, assessment ) {\n\t\tassessment.name = name;\n\t\tassessment.setResearcher( this.researcher );\n\t\tthis._assessments.push( assessment );\n\t}\n\n\t/**\n\t * Removes the assessment registered under the given name, if it exists.\n\t *\n\t * @param {string} name The name of the assessment to remove.\n\t *\n\t * @returns {module:tree/assess.Assessment|null} The deleted assessment, or null if no assessment has been deleted.\n\t */\n\tremoveAssessment( name ) {\n\t\tconst index = this._assessments.findIndex( assessment => assessment.name === name );\n\t\tif ( index > -1 ) {\n\t\t\tconst deleted = this._assessments.splice( index, 1 );\n\t\t\treturn deleted[ 0 ];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the assessment registered under the given name.\n\t * Returns `null` if no assessment is registered under the given name.\n\t *\n\t * @param {string} name The name of the assessment to get.\n\t *\n\t * @returns {Assessment|null} The assessment.\n\t */\n\tgetAssessment( name ) {\n\t\tconst assessmentToReturn = this._assessments.find( assessment => assessment.name === name );\n\t\treturn assessmentToReturn ? assessmentToReturn : null;\n\t}\n\n\t/**\n\t * Sets the assessments that this assessor needs to apply.\n\t *\n\t * @param {module:tree/assess.Assessment[]} assessments The assessments to set.\n\t *\n\t * @returns {void}\n\t */\n\tsetAssessments( assessments ) {\n\t\tthis._assessments = assessments;\n\t}\n\n\t/**\n\t * Returns the list of applicable assessments.\n\t *\n\t * @param {Paper}                      paper The paper to check.\n\t * @param {module:tree/structure.Node} node  The tree to check.\n\t *\n\t * @returns {Promise<Array>} The list of applicable assessments.\n\t */\n\tasync getApplicableAssessments( paper, node ) {\n\t\t// List to store the applicable assessments in (empty for now).\n\t\tconst applicableAssessments = [];\n\n\t\t// Asynchronously add each assessment to the list if they are applicable.\n\t\tconst promises = this._assessments.map( assessment =>\n\t\t\tassessment.isApplicable( paper, node ).then(\n\t\t\t\tapplicable => {\n\t\t\t\t\tif ( applicable ) {\n\t\t\t\t\t\tapplicableAssessments.push( assessment );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\n\t\t// Wait before all the applicable assessments have been added before returning them.\n\t\treturn Promise.all( promises ).then( () => applicableAssessments );\n\t}\n}\n\nexport default TreeAssessor;\n"]}