{"version":3,"sources":["../../../../src/tree/research/TreeResearcher.js"],"names":["TreeResearcher","_researches","_data","name","research","hasResearch","Error","node","bustCache","getResearch","researchResult","Promise","resolve","isLeafNode","hasResearchResult","setResearchResult","calculateFor","getResearchResult","children","resultsForChildren","all","map","child","doResearch","mergeChildrenResults","researchName","data"],"mappings":";;;;;;;;AAAA;;;;AAEA;;;;;;;IAOMA,c;AACL;;;AAGA,2BAAc;AAAA;;AACb,OAAKC,WAAL,GAAmB,EAAnB;AACA,OAAKC,KAAL,GAAa,EAAb;AACA;;AAED;;;;;;;;;;;;;;;8BAWaC,I,EAAMC,Q,EAAW;AAC7B,QAAKH,WAAL,CAAkBE,IAAlB,IAA2BC,QAA3B;AACA;;AAED;;;;;;;;kCAKgB;AACf,UAAO,KAAKH,WAAZ;AACA;;AAED;;;;;;;;;;8BAOaE,I,EAAO;AACnB,UAAO,mBAAK,KAAKF,WAAV,EAAuBE,IAAvB,CAAP;AACA;;AAED;;;;;;;;;;;;;8BAUaA,I,EAAO;AACnB,OAAK,KAAKE,WAAL,CAAkBF,IAAlB,CAAL,EAAgC;AAC/B,WAAO,KAAKF,WAAL,CAAkBE,IAAlB,CAAP;AACA;AACD,SAAM,IAAIG,KAAJ,OAAeH,IAAf,gCAAN;AACA;;AAED;;;;;;;;;;;;mCASkBA,I,EAAMI,I,EAA0B;AAAA;;AAAA,OAApBC,SAAoB,uEAAR,KAAQ;;AACjD,OAAMJ,WAAW,KAAKK,WAAL,CAAkBN,IAAlB,CAAjB;AACA,OAAIO,iBAAiBC,QAAQC,OAAR,EAArB;;AAEA,OAAKR,SAASS,UAAT,CAAqBN,IAArB,CAAL,EAAmC;AAClC;;;;AAIA,QAAK,CAAEA,KAAKO,iBAAL,CAAwBX,IAAxB,CAAF,IAAoCK,SAAzC,EAAqD;AACpDD,UAAKQ,iBAAL,CAAwBZ,IAAxB,GAA8B,MAAMC,SAASY,YAAT,CAAuBT,IAAvB,CAApC;AACA;AACDG,qBAAiBH,KAAKU,iBAAL,CAAwBd,IAAxB,CAAjB;AACA,IATD,MASO;AACN,QAAMe,WAAWX,KAAKW,QAAtB;;AAEA;AACA,QAAKA,QAAL,EAAgB;AACf,SAAMC,qBAAqB,MAAMR,QAAQS,GAAR,CAAaF,SAASG,GAAT,CAAc,UAAEC,KAAF,EAAa;AACxE,aAAO,MAAKC,UAAL,CAAiBpB,IAAjB,EAAuBmB,KAAvB,CAAP;AACA,MAF6C,CAAb,CAAjC;;AAIAZ,sBAAiBN,SAASoB,oBAAT,CAA+BL,kBAA/B,CAAjB;AACA;AACD;;AAED,UAAOT,cAAP;AACA;;AAED;;;;;;;;;;;kCAQiBe,Y,EAAcC,I,EAAO;AACrC,QAAKxB,KAAL,CAAYuB,YAAZ,IAA6BC,IAA7B;AACA;;AAED;;;;;;;;;;0BAOSD,Y,EAAe;AACvB,UAAO,mBAAK,KAAKvB,KAAV,EAAiBuB,YAAjB,EAA+B,KAA/B,CAAP;AACA;;;;;;kBAGazB,c","file":"TreeResearcher.js","sourcesContent":["import { get, has } from \"lodash-es\";\n\n/**\n * This contains all possible, default researches\n * and logic to apply these researches to a formatted text,\n * represented as a tree structure.\n *\n * @memberOf module:tree/research\n */\nclass TreeResearcher {\n\t/**\n\t * Makes a new TreeResearcher.\n\t */\n\tconstructor() {\n\t\tthis._researches = {};\n\t\tthis._data = {};\n\t}\n\n\t/**\n\t * Adds or overwrites a research to the list of available researches.\n\t *\n\t * **Note**: When a research is already known under the given name,\n\t * the previous research with this name gets overwritten!\n\t *\n\t * @param {string} name       The ID to which to map the research to.\n\t * @param {Research} research The research to add.\n\t *\n\t * @returns {void}\n\t */\n\taddResearch( name, research ) {\n\t\tthis._researches[ name ] = research;\n\t}\n\n\t/**\n\t * Returns all available researches.\n\t *\n\t * @returns {Object} An object containing all available researches.\n\t */\n\tgetResearches() {\n\t\treturn this._researches;\n\t}\n\n\t/**\n\t * Returns whether a research is known under this name.\n\t *\n\t * @param {string} name The name to get the research from.\n\t *\n\t * @returns {boolean} If a research is known under this name.\n\t */\n\thasResearch( name ) {\n\t\treturn has( this._researches, name );\n\t}\n\n\t/**\n\t * Gets the research with the given name.\n\t * If a research is not known under this name, false is returned instead.\n\t *\n\t * @throws {Error} When a research is not known under the given name.\n\t *\n\t * @param {string} name The name of the research to get.\n\t *\n\t * @returns {Research} The research stored under the given name.\n\t */\n\tgetResearch( name ) {\n\t\tif ( this.hasResearch( name ) ) {\n\t\t\treturn this._researches[ name ];\n\t\t}\n\t\tthrow new Error( `'${name}' research does not exist.` );\n\t}\n\n\t/**\n\t * Applies the research with the given name to the node and its descendants.\n\t *\n\t * @param {string} name                     The name of the research to apply to the node.\n\t * @param {module:tree/structure.Node} node The node to compute the research of.\n\t * @param {boolean} [bustCache=false]       If we should force the results, as cached on each node, to be recomputed.\n\t *\n\t * @returns {Promise<*>} A promising research result.\n\t */\n\tasync doResearch( name, node, bustCache = false ) {\n\t\tconst research = this.getResearch( name );\n\t\tlet researchResult = Promise.resolve();\n\n\t\tif ( research.isLeafNode( node ) ) {\n\t\t\t/*\n\t\t\t  Compute research results for this node, or use the cached results when available.\n\t\t\t  Always compute it when we need to bust the cache.\n\t\t\t */\n\t\t\tif ( ! node.hasResearchResult( name ) || bustCache ) {\n\t\t\t\tnode.setResearchResult( name, await research.calculateFor( node ) );\n\t\t\t}\n\t\t\tresearchResult = node.getResearchResult( name );\n\t\t} else {\n\t\t\tconst children = node.children;\n\n\t\t\t// Heading and paragraph nodes do not have children.\n\t\t\tif ( children ) {\n\t\t\t\tconst resultsForChildren = await Promise.all( children.map( ( child ) => {\n\t\t\t\t\treturn this.doResearch( name, child );\n\t\t\t\t} ) );\n\n\t\t\t\tresearchResult = research.mergeChildrenResults( resultsForChildren );\n\t\t\t}\n\t\t}\n\n\t\treturn researchResult;\n\t}\n\n\t/**\n\t * Add research data to the researcher by the research name.\n\t *\n\t * @param {string} researchName The identifier of the research.\n\t * @param {Object} data         The data object.\n\t *\n\t * @returns {void}.\n\t */\n\taddResearchData( researchName, data ) {\n\t\tthis._data[ researchName ] = data;\n\t}\n\n\t/**\n\t * Return the research data from a research data provider by research name.\n\t *\n\t * @param {string} researchName The identifier of the research.\n\t *\n\t * @returns {Object|boolean} The data provided by the provider, false if the data do not exist\n\t */\n\tgetData( researchName ) {\n\t\treturn get( this._data, researchName, false );\n\t}\n}\n\nexport default TreeResearcher;\n"]}