{"version":3,"sources":["../../../../../src/tree/structure/nodes/Node.js"],"names":["Node","type","sourceStartIndex","sourceEndIndex","_researchResult","researchName","researchResult","mapFunction","node","children","length","map","child","fun","forEach","indentation","JSON","stringify","_removeParent","key","value"],"mappings":";;;;;;;;AAAA;;;;AAEA;;;;;;IAMMA,I;AACL;;;;;;;AAOA,eAAaC,IAAb,EAAoB;AAAA;;AACnB;;;;AAIA,OAAKA,IAAL,GAAYA,IAAZ;AACA;;;;AAIA,OAAKC,gBAAL,GAAwB,CAAxB;AACA;;;;AAIA,OAAKC,cAAL,GAAsB,CAAtB;AACA;;;;;AAKA,OAAKC,eAAL,GAAuB,EAAvB;AACA;;AAED;;;;;;;;;;;;oCAQmBC,Y,EAAcC,c,EAAiB;AACjD,QAAKF,eAAL,CAAsBC,YAAtB,IAAuCC,cAAvC;AACA;;AAED;;;;;;;;;;oCAOmBD,Y,EAAe;AACjC,UAAO,mBAAK,KAAKD,eAAV,EAA2BC,YAA3B,EAAyC,IAAzC,CAAP;AACA;;AAED;;;;;;;;;;oCAOmBA,Y,EAAe;AACjC,UAAO,mBAAK,KAAKD,eAAV,EAA2BC,YAA3B,CAAP;AACA;;AAED;;;;;;;;;;sBAOKE,W,EAAc;AAClB;AACA,OAAMC,OAAOD,YAAa,IAAb,CAAb;AACA,OAAKC,KAAKC,QAAL,IAAiBD,KAAKC,QAAL,CAAcC,MAAd,GAAuB,CAA7C,EAAiD;AAChD;AACAF,SAAKC,QAAL,GAAgBD,KAAKC,QAAL,CAAcE,GAAd,CAAmB;AAAA,YAASC,MAAMD,GAAN,CAAWJ,WAAX,CAAT;AAAA,KAAnB,CAAhB;AACA;AACD,UAAOC,IAAP;AACA;;AAED;;;;;;;;;;AAUA;;;;;;;;;;0BAOSK,G,EAAM;AACdA,OAAK,IAAL;AACA,OAAK,KAAKJ,QAAL,IAAiB,KAAKA,QAAL,CAAcC,MAAd,GAAuB,CAA7C,EAAiD;AAChD,SAAKD,QAAL,CAAcK,OAAd,CAAuBD,GAAvB;AACA;AACD;;AAED;;;;;;;;;;;;;;;;AAkBA;;;;;;;;6BAQ4B;AAAA,OAAlBE,WAAkB,uEAAJ,CAAI;;AAC3B,UAAOC,KAAKC,SAAL,CAAgB,IAAhB,EAAsBjB,KAAKkB,aAA3B,EAA0CH,WAA1C,CAAP;AACA;;;gCAjBqBI,G,EAAKC,K,EAAQ;AAClC,OAAKD,QAAQ,QAAb,EAAwB;AACvB;AACA;AACD,UAAOC,KAAP;AACA;;;;;;kBAeapB,I","file":"Node.js","sourcesContent":["import { has, get } from \"lodash-es\";\n\n/**\n * Abstract class representing a node in the structured tree.\n * @abstract\n *\n * @memberOf module:tree/structure\n */\nclass Node {\n\t/**\n\t * Makes a new Node.\n\t *\n\t * @param {string} type The type of Node (should be unique for each child class of Node).\n\t *\n\t * @abstract\n\t */\n\tconstructor( type ) {\n\t\t/**\n\t\t * Type of node (unique for each child class of Node).\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * Start of this element (including tags) within the source text.\n\t\t * @type {?number}\n\t\t */\n\t\tthis.sourceStartIndex = 0;\n\t\t/**\n\t\t * End of this element (including tags) within the source text.\n\t\t * @type {?number}\n\t\t */\n\t\tthis.sourceEndIndex = 0;\n\t\t/**\n\t\t * Cache for the research results.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._researchResult = {};\n\t}\n\n\t/**\n\t * Stores the research result on this node.\n\t *\n\t * @param {string} researchName   The name of the research of which to store the results.\n\t * @param {Object} researchResult The results to store.\n\t *\n\t * @returns {void}\n\t */\n\tsetResearchResult( researchName, researchResult ) {\n\t\tthis._researchResult[ researchName ] = researchResult;\n\t}\n\n\t/**\n\t * Returns the research result for the research with the given name.\n\t *\n\t * @param {string} researchName The name of the research of which to return the stored results.\n\t *\n\t * @returns {Object|null} The stored results, or null if not found.\n\t */\n\tgetResearchResult( researchName ) {\n\t\treturn get( this._researchResult, researchName, null );\n\t}\n\n\t/**\n\t * Checks whether results exist for the research with the given name.\n\t *\n\t * @param {string} researchName The name of the research to check.\n\t *\n\t * @returns {boolean} Whether results exists for the research with the given name.\n\t */\n\thasResearchResult( researchName ) {\n\t\treturn has( this._researchResult, researchName );\n\t}\n\n\t/**\n\t * Maps the given function to each Node in this tree.\n\t *\n\t * @param {module:tree/structure.Node.mapFunction} mapFunction The function that should be mapped to each Node in the tree.\n\t *\n\t * @returns {module:tree/structure.Node} A new tree, after the given function has been mapped on each Node.\n\t */\n\tmap( mapFunction ) {\n\t\t// Map function over contents of this node.\n\t\tconst node = mapFunction( this );\n\t\tif ( node.children && node.children.length > 0 ) {\n\t\t\t// Map function over node's children (if it has any).\n\t\t\tnode.children = node.children.map( child => child.map( mapFunction ) );\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Callback function for the Node's map-function.\n\t *\n\t * @callback module:tree/structure.Node.mapFunction\n\t *\n\t * @param {module:tree/structure.Node} currentValue The current Node being processed.\n\t *\n\t * @returns {module:tree/structure.Node} The current Node after being processed by this function.\n\t */\n\n\t/**\n\t * Executes the given function on each node in this tree.\n\t *\n\t * @param{function} fun The function to apply to each node in the tree.\n\t *\n\t * @returns {void}\n\t */\n\tforEach( fun ) {\n\t\tfun( this );\n\t\tif ( this.children && this.children.length > 0 ) {\n\t\t\tthis.children.forEach( fun );\n\t\t}\n\t}\n\n\t/**\n\t * Custom replacer function for replacing 'parent' with nothing.\n\t * This is done to remove cycles from the tree.\n\t *\n\t * @param {string} key   The key.\n\t * @param {Object} value The value.\n\t *\n\t * @returns {Object} The (optionally replaced) value.\n\t *\n\t * @private\n\t */\n\tstatic _removeParent( key, value ) {\n\t\tif ( key === \"parent\" ) {\n\t\t\treturn;\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Transforms this tree to a string representation.\n\t * For use in e.g. logging to the console or to a text file.\n\t *\n\t * @param {number|string} [indentation = 2] The space with which to indent each successive level in the JSON tree.\n\t *\n\t * @returns {string} This tree, transformed to a string.\n\t */\n\ttoString( indentation = 2 ) {\n\t\treturn JSON.stringify( this, Node._removeParent, indentation );\n\t}\n}\n\nexport default Node;\n"]}